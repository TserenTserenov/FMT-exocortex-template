# ADR-002: Модульная архитектура ролей

**Статус:** Принято
**Дата:** 2026-03-01
**Контекст:** FMT-exocortex-template/roles, PACK-digital-platform (DP.D.033, DP.AGENT.001)

---

## Контекст

Шаблон экзокортекса поставляет 3 роли: Стратег (R1), Экстрактор (R2), Синхронизатор (R8). Каждая — отдельная директория в `roles/`, но имена ролей были жёстко прописаны (hardcoded) в `setup.sh`, `update.sh`, `scheduler.sh` и `notify.sh`.

Замечание рецензента (Евгений Миллер, 2026-03-01): «Pack вынесены в отдельные модули, а роли остались внутри шаблона. Для меня основная ценность — в описаниях Pack и ролей, а не в конкретной реализации сервиса.»

## Проблема

1. **Hardcoded роли.** Добавление новой роли требует правки 4 скриптов (`setup.sh`, `update.sh`, `scheduler.sh`, `notify.sh`) — даже если структура директории корректна.
2. **Неявный контракт.** Три роли следуют одному паттерну (README + install.sh + prompts/ + scripts/), но этот паттерн нигде не формализован. Новый пользователь должен реверс-инжинирить структуру по примерам.
3. **Знание зашито в код.** Роль — это доменное знание (DP.D.033: что делать, какие обязательства, какие РП). Но описание роли и её реализация смешаны в одной директории без явного разделения.

**АрхГейт (ЭМОГССБ):**

| Характеристика | Было (hardcoded) | Стало (modular) |
|----------------|-----------------|----------------|
| Эволюционируемость | 6 | 9 |
| Масштабируемость | 5 | 9 |
| Обучаемость | 6 | 9 |
| Генеративность | 5 | 8 |
| Скорость | 10 | 10 |
| Современность | 6 | 8 |
| Безопасность | 9 | 9 |
| **Среднее** | **6.7** | **8.9** |

Текущее решение ниже порога 8. Масштабируемость (5) и Генеративность (5) — критически низкие: пользователь не может добавить свою роль без чтения 4 скриптов.

## Альтернативы

### A. Центральный реестр (roles.yaml в корне)

Один файл `roles/roles.yaml` перечисляет все роли. Скрипты читают его.

- (+) Единая точка регистрации
- (−) Два источника правды: реестр + директория. Рассинхронизация при добавлении роли без обновления реестра
- (−) Нарушает принцип автономности модуля — роль зависит от внешнего файла

### B. Манифест в каждой роли (role.yaml) + автодискавери

Каждая роль содержит `role.yaml` с метаданными. Скрипты сканируют `roles/*/role.yaml`.

- (+) Роль самодостаточна (как Pack-репо: всё в одной директории)
- (+) Добавление = создание директории. Без правки внешних файлов
- (+) Удаление = удаление директории. Без чистки реестра
- (−) grep по YAML без парсера — хрупко для сложных структур
- (−) Нет контроля порядка (mitigated: `install.priority`)

### C. Convention-only (без манифеста)

Автодискавери по структуре: есть `install.sh` → роль. Метаданные не нужны.

- (+) Никаких новых файлов
- (−) Нет способа отличить auto-install от manual-install
- (−) Нет машиночитаемых метаданных (display_name, type, id)
- (−) Нельзя связать с каталогом DP.AGENT.001

## Решение

**Вариант B: role.yaml + автодискавери.**

Обоснование:
- **Автономность модуля.** Как Pack-репо содержит всё для предметной области, так директория роли содержит всё для роли — включая манифест. Аналогия с `package.json` в npm-пакете.
- **Convention over configuration.** Парсинг role.yaml — простой `grep` по плоским полям верхнего уровня. Не требует `yq`, `python` или других зависимостей. Для 3-10 ролей достаточно.
- **Связь с Pack.** Поле `id: R1` в role.yaml связывает реализацию с source-of-truth в DP.AGENT.001 §3.2. Это трейсабельность: контракт шаблона → каталог ролей → описание роли (DP.D.033).
- **Прецедент:** ADR-001 показал, что генеративность (fork = работающая система) — приоритет. Модульные роли усиливают этот принцип: пользователь может добавить свою роль без понимания внутренностей скриптов.

## Что изменилось

**Новые файлы:**
- `roles/ROLE-CONTRACT.md` — формальная спецификация (обязательные/опциональные файлы, схема role.yaml)
- `roles/strategist/role.yaml` — манифест R1
- `roles/extractor/role.yaml` — манифест R2
- `roles/synchronizer/role.yaml` — манифест R8

**Изменённые скрипты:**
- `setup.sh` — цикл по `roles/*/role.yaml` вместо hardcoded Strategist
- `update.sh` — цикл по `roles/*/install.sh` вместо 3 if/else
- `scheduler.sh` — `get_role_runner()` читает `runner:` из role.yaml с convention-based fallback
- `notify.sh` — динамический список агентов из `templates/*.sh`

**Документация:**
- `roles/README.md` — переписана секция «Как добавить роль»
- `ONTOLOGY.md` — ссылка на ROLE-CONTRACT.md
- `docs/LEARNING-PATH.md` — §7.4 «Контракт роли»
- `DP.AGENT.001` (Pack) — примечание о контракте ролей в шаблоне
- `DP.D.033` (Pack) — §8 «Модульность ролей как следствие»

## Принципы

- **Автономность модуля** — роль самодостаточна: манифест + описание + реализация в одной директории
- **Генеративность** — пользователь добавляет роль по контракту без правки инфраструктуры
- **Трейсабельность** — role.yaml → DP.AGENT.001 §3.2 → DP.D.033 (от кода к знанию)
- **Convention over configuration** — grep по YAML, без парсера, минимальная сложность

## Что НЕ изменилось (осознанные границы)

- **scheduler.sh dispatch** — логика расписания остаётся hardcoded. Полный config-driven dispatch (чтение schedule: из role.yaml) — отдельная задача, когда ролей станет >5. Сейчас config.yaml в synchronizer/ документирует расписание, scheduler.sh его не читает.
- **Расписание** — по-прежнему в `synchronizer/config.yaml`, не в role.yaml. Одно место для всего расписания лучше, чем N фрагментов по N ролям.
- **Описание роли (DP.D.033 шаблон)** — по-прежнему в README.md каждой роли (и в system.yaml в DS-ai-systems). role.yaml не дублирует обязательства/методы — только операционные метаданные.

## Последствия

- template-sync.sh: добавить role.yaml × 3 и ROLE-CONTRACT.md в sync-manifest
- Пользователи существующих форков: при `update.sh` новые role.yaml появятся автоматически
- Будущие роли: создаются по контракту без правки скриптов
